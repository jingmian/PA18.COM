////////////////////////////////////////////////////////
// Changed by: ZhanYB
// Function:   Manager all connection in the pool include get ,retuan ,release
// Used Class: LogWrite
// Update Date:2000/7/20
// Update by cidy on 10/01/2001 for reconnect db after db fail and start again
// this update include add some neccessry items for special need
////////////////////////////////////////////////////////

package utility;

import java.io.PrintWriter;
import java.sql.*;
import java.util.Enumeration;
import java.util.Vector;

public class ConnectionPool
{
    private String name;
    private String URL;
    private String user;
    private String password;
    private int initConns;
    private int maxConns;
    private int timeOut;
    private PrintWriter pwriter;
    private LogWriter logWriter;
    private int checkedOut;
    private Vector freeConnections;
    private int loglvl;

////////////////////////////////////////////////////////
//Create Connection Pool
//input: pool name; URL; user;
//       password; maxConns; initConns; timeOut
////////////////////////////////////////////////////////

    public ConnectionPool(String s, String s1, String s2, String s3, int i, int j, int k,
            PrintWriter printwriter, int l){
        freeConnections = new Vector();
        name = s;
        URL = s1;
        user = s2;
        password = s3;
        maxConns = i;
	initConns=j;
        timeOut = k <= 0 ? 5 : k;
	pwriter=printwriter;
	loglvl=l;
        logWriter = new LogWriter(s, l, printwriter);
        initPool(j);
        logWriter.log("New pool created", 2);
        String s4 = System.getProperty("line.separator");
        logWriter.log(s4 + " url=" + s1 + s4 + " user=" + s2 + s4 + " password=" + s3 + s4 + " initconns=" + j + s4 + " maxconns=" + i + s4 + " logintimeout=" + timeOut, 2);
        logWriter.log(getStats(), 2);
    }

////////////////////////////////////////////////////////
//init pool
////////////////////////////////////////////////////////

    private void initPool(int i){
	for(int j = 0; j < i; j++){
	    try{
                Connection connection = newConnection();
                freeConnections.addElement(connection);
	    }
	    catch(SQLException _ex) { 
	    }
	}
    }

    ///////////////////////////////////////////
    //this is used reconnect db after detected the db is not available
    //this is added by cidy long on 10/01/2001
    //////////////////////////////////////////
    private void reConnect(){
	//System.out.println("before reconnection!!");
	try{
	    Connection connection = newConnection();
	    if (!(connection==null)){
		//System.out.println("new connection is ok, db available now");
		checkedOut=0;
		freeConnections.clear();
		initPool(initConns);
	    }
	}
	catch(Exception e){
	    //System.out.println("create connection fail");
	}
	//System.out.println("after reconnection the pool have "+freeConnections.size()+" connections!!");
    }

////////////////////////////////////////////////////////
//get connection
////////////////////////////////////////////////////////

    public Connection getConnection()
        throws SQLException
    {
        logWriter.log("Request for connection received", 3);
        try
        {
            return getConnection(timeOut * 1000);
        }
        catch(SQLException sqlexception)
        {
            logWriter.log(sqlexception, "Exception getting connection", 2);
            throw sqlexception;
        }
    }

    private synchronized Connection getConnection(long l)
        throws SQLException
    {
        long l1 = System.currentTimeMillis();
        long l2 = l;
        Connection connection=null;
      while ((connection = getPooledConnection()) == null)
        {
            try
            {
                logWriter.log("Waiting for connection. Timeout=" + l2, 2);
                wait(l2);
            }
            catch(InterruptedException _ex) { }
            l2 = l - (System.currentTimeMillis() - l1);
            if(l2 <= 0L)
            {
                logWriter.log("Time-out while waiting for connection", 2);
                throw new SQLException("getConnection() timed-out");
            }
        }

        if(!isConnectionOK(connection))
        {
            //System.out.println("Connection is bad, that generated by isConnectionOK function, ClarkRao");
            logWriter.log("Removed selected bad connection from pool", 2);
            return getConnection(l2);
        }
        else
        {
	    int currentconns=freeConnections.size() + checkedOut;
	    if (currentconns+1 < initConns){
		//System.out.println("total connection: " +currentconns+"\n"+"the initial connections: "+initConns);

		freeConnections.clear();
		reConnect();
		//checkedOut--;
	    }
            checkedOut++;
	    String poolstat=getStats();
	    //System.out.println("after get connection status: "+poolstat);
            logWriter.log("Delivered connection from pool", 2);
            logWriter.log(poolstat, 2);
            return connection;
        }
    }

////////////////////////////////////////////////////////
//check connect
////////////////////////////////////////////////////////

    private boolean isConnectionOK(Connection connection)
    {
        Statement statement = null;
        try
        {
            if(!connection.isClosed())
            {
                statement = connection.createStatement();
                statement.close();
            }
            else
            {
                return false;
            }
        }
        catch(SQLException sqlexception)
        {
	    //System.out.println("check connect fail at isConnectionOK");
            if(statement != null){
		//System.out.println("but the statement is not null");
                try{
		    statement.close();
		}
                catch(SQLException _ex) { }
	    }
            logWriter.log("Pooled Connection was not okay", 2);
	    logWriter.log("try reconnect the db by pool manager",2);
	    //System.out.println("before call reconnect");
	    reConnect();
            return false;
        }
        //the following condition was added by cidy to handle the connections not be return to the pool we need the connection pool to reconnect.
        if (checkedOut>=maxConns-1 || checkedOut<0){
            logWriter.log("The checked out connections is nearly max number.",2);
            logWriter.log("try reconnect the db by pool manager",2);
            reConnect();
            return false;
        }
        return true;
    }

////////////////////////////////////////////////////////
//get pooled connection
////////////////////////////////////////////////////////

    private Connection getPooledConnection()
        throws SQLException
    {
        Connection connection = null;
        if(freeConnections.size() > 0)
        {
            connection = (Connection)freeConnections.firstElement();
            freeConnections.removeElementAt(0);
        }
        else
        if(maxConns == 0 || checkedOut < maxConns)
            connection = newConnection();
        return connection;
    }


////////////////////////////////////////////////////////
//new connection
////////////////////////////////////////////////////////

    private Connection newConnection()
        throws SQLException
    {
        Connection connection = null;
        try{
	    if(user == null)
		connection = DriverManager.getConnection(URL);
	    else
		connection = DriverManager.getConnection(URL, user, password);
	    logWriter.log("Opened a new connection", 2);
	}
	catch(SQLException sqlexception){
	    //System.out.println("con't create new connection!!");
	    logWriter.log("Couldn't get new connection", 2);
	    throw sqlexception;
	}
        return connection;
    }

////////////////////////////////////////////////////////
//free connection
////////////////////////////////////////////////////////

    public synchronized void freeConnection(Connection connection)
    {
        freeConnections.addElement(connection);
        checkedOut--;
        notifyAll();
        logWriter.log("Returned connection to pool", 2);
	String poolstat=getStats();
	//System.out.println("after free connection status: "+poolstat);
        logWriter.log(poolstat, 2);
    }


////////////////////////////////////////////////////////
//release connection
////////////////////////////////////////////////////////

    public synchronized void release()
    {
        for(Enumeration enumeration = freeConnections.elements(); enumeration.hasMoreElements();)
        {
            Connection connection = (Connection)enumeration.nextElement();
            try
            {
                connection.close();
                logWriter.log("Closed connection", 2);
            }
            catch(SQLException sqlexception)
            {
                logWriter.log(sqlexception, "Couldn't close connection", 2);
            }
        }

        freeConnections.removeAllElements();
    }


    private String getStats()
    {
        return "Total connections: " + (freeConnections.size() + checkedOut) + " Available: " + freeConnections.size() + " Checked-out: " + checkedOut;
    }

    public String getStatusString(){
	return getStats();
    }
}
